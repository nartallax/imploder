TODO:

tslib по мере надобности
минификация кода
минификация кода лоадера, вшиваемого в бандлер
проверить под виндой
проверить удаление модулей в девмоде
разделение сред в опциях: девелопмент/прод, два множества оверрайдов
удалять кеши при старте тула
понять, как заставить среду ссылаться по абсолютным путям всегда, а не по относительным иногда
опции: что делать с именами асинхронных импортов, что делать с кешами при старте, минификация
трансформер, который не меняет AST, точно должен быть трансформером? может, там есть другие, более легковесные варианты?
exports.__esModule = true; или Object.defineProperty(exports, "__esModule", { value: true });

ТЕСТЫ:

проверить, что use strict действует внутри модулей (и в лоадере..?)
альтернативные имена через <amd-module> работают как надо (прокидываются в лоадер; вызов define правильно разбирается)
<amd-require> или как его там вообще работает (варнинг/подключение зависимости)
пересечение по именам пользовательских и уже имеющихся модулей, типа import * from "./fs"
импорты, из которых используются только типы, обрабатываются корректно
import "./myMod" - для сайд-эффектов - обрабатывается корректно
export * from работает aka проверить, что по пропертям модуля можно проитерироваться
рекурсивные export * from "modulename" падают, и чем раньше, тем лучше
export { x as y } from "z"
рекурсивные "export =" падают (потому что это циклические ссылки в рантайме)
внешние модули можно сослать через import (типа import * as fs from "fs")
default-экспорт не реэкспортируется через export * from
варнинг в случае коллизий имен в случае export * from. однозначное разрешение ситуации
правильная работа с асинхронными и синхронными require
имена экспортируемых значений присутствуют в данных о модулях для случая более чем одного цикла импортов

ДОКИ:

про dynamic imports
про опции в tsconfig.json
про запрет не-модульных файлов
про скоуп исполнения бандла

Про require:
TL;DR: preferCommonjs = true для сборки под NodeJS, false для сборки под браузер  
Тулу можно сообщить два варианта require - amdRequire и commonjsRequire, а также передавать флаг preferCommonjs.
amdRequire будет использован в случае, когда из кода явно асинхронно запрошена зависимость; commonjsRequire - когда явно синхронно. preferCommonjs определяет, как именно следует подгружать зависимости в случае, когда их требует какой-либо еще модуль (и их определения нет у лоадера).  
Обычно в среде исполнения определена только одна из этих функций, и она известна под именем require, так что явно указывать amdRequire и commonjsRequire нужно только в случае, если вы хотите передать туда какую-нибудь другую функцию. preferCommonjs следует задавать true для исполнения в среде NodeJS и false - для браузера. Это будет изменять ожидания лоадера от require.  
Из этого следует, что при такой конфигурации без явных дополнительных усилий в браузере не будет работать синхронный require, а в NodeJS - асинхронный.