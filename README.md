TODO:

tslib при старых таргетах
минификация кода
минификация кода лоадера, вшиваемого в бандлер
проверить под виндой
проверить удаление модулей в девмоде
разделение сред в опциях: девелопмент/прод, два множества оверрайдов
удалять кеши при старте тула
понять, как заставить среду ссылаться по абсолютным путям всегда, а не по относительным иногда
что такое NamespaceImport в моменте анализа списка импортируемого из модуля?
попробовать поюзать checker.getExportsOfModule

Посмотреть, чего там за флаг --esnext и чего там за модули
Подумать, как поиспользовать tsc --listFiles и tsc --traceResolution и зачем

ТЕСТЫ:

пересечение по именам пользовательских и уже имеющихся модулей, типа import * from "./fs" - что делать?
импорты, из которых используются только типы, обрабатываются корректно
import "./myMod" - для сайд-эффектов - обрабатывается корректно
export * from работает aka проверить, что по пропертям модуля можно проитерироваться
рекурсивные export * from "modulename" падают, и чем раньше, тем лучше
рекурсивные "export =" падают (потому что это циклические ссылки в рантайме)
внешние модули можно сослать через import (типа import * as fs from "fs")
default-экспорт не реэкспортируется через export * from
варнинг в случае коллизий имен в случае export * from. однозначное разрешение ситуации
правильная работа с асинхронными и синхронными require

ДОКИ:

про dynamic imports
про опции в tsconfig.json
про запрет не-модульных файлов
про скоуп исполнения бандла

Про require:
TL;DR: preferCommonjs = true для сборки под NodeJS, false для сборки под браузер  
Тулу можно сообщить два варианта require - amdRequire и commonjsRequire, а также передавать флаг preferCommonjs.
amdRequire будет использован в случае, когда из кода явно асинхронно запрошена зависимость; commonjsRequire - когда явно синхронно. preferCommonjs определяет, как именно следует подгружать зависимости в случае, когда их требует какой-либо еще модуль (и их определения нет у лоадера).  
Обычно в среде исполнения определена только одна из этих функций, и она известна под именем require, так что явно указывать amdRequire и commonjsRequire нужно только в случае, если вы хотите передать туда какую-нибудь другую функцию. preferCommonjs следует задавать true для исполнения в среде NodeJS и false - для браузера. Это будет изменять ожидания лоадера от require.  
Из этого следует, что при такой конфигурации без явных дополнительных усилий в браузере не будет работать синхронный require, а в NodeJS - асинхронный.